{"meta":{"title":"23.9K | Vineo","subtitle":"生活不止眼前的苟且，还有诗和远方的田野","description":"生活不止眼前的苟且，还有诗和远方的田野","author":"23.9K","url":"https://vineo.cn"},"pages":[{"title":"","date":"2019-11-13T14:11:28.289Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"404.html","permalink":"https://vineo.cn/404.html","excerpt":"","text":""},{"title":"about","date":"2018-11-04T23:49:21.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"about/index.html","permalink":"https://vineo.cn/about/index.html","excerpt":"","text":"喜欢写写东西，写写代码喜欢看电影，美剧（权游迷兼西部迷）旅游，摄影，绘画，等等等。。。。 hello world, I’m ‘1/3blue’ 目前的职业是：web前端前端工程师，俗称码农一枚。 目前的技能: 前端三大件,angular|vue|knockout(这玩意儿，我TM居然用了两年)以及一些包管理器， 后端: java和目前正在学习的python。"},{"title":"tags","date":"2018-11-08T00:07:18.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"tags/index.html","permalink":"https://vineo.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"通过 github action 自动发布博客","slug":"how-to-auto-publish-blog","date":"2019-11-13T22:09:22.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"how-to-auto-publish-blog.html","link":"","permalink":"https://vineo.cn/how-to-auto-publish-blog.html","excerpt":"前言本博客原来的自动化是通过travis 来完成自动发布，由于github 发布了action 所以将采用github的CI 来进行博客的发布。","text":"前言本博客原来的自动化是通过travis 来完成自动发布，由于github 发布了action 所以将采用github的CI 来进行博客的发布。 如何使用 在所有的工作开始之前，我们生成部署公私钥 ssh-keygen -t rsa -b 4096 -C &quot;charlesmaxwellyoung@gmail.com&quot; -f ~/.ssh/github-actions-deploy 在~/.ssh目录中找到刚刚生成的包含github-actions-deploy文件 其中的pub是公钥，放置在 Github Pages 的仓库，Settings -&gt; Deploy keys 添加刚刚生成的公钥，名称随意，但要勾选 Allow write access。 另外一个是私钥，放置在新仓库的 Settings -&gt; Secrets 里添加刚刚生成的私钥，名称为 BLOG_ACTION。 编写workflow，文件位置.github/workflows/deploy.yml 12345678910111213141516171819202122232425262728293031name: build and auto publish github pageson: [push]jobs: builds: runs-on: ubuntu-latest strategy: matrix: node-version: [10.x] steps: - uses: actions/checkout@v1 - name: begin setup node uses: actions/setup-node@v1 with: node-version: \"10.x\" - name: setup hexo env env: ACTION_DEPLOY_KEY: $&#123;&#123;secrets.BLOG_ACTION&#125;&#125; run: | mkdir -p ~/.ssh/ echo \"$ACTION_DEPLOY_KEY\" &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name 'yy921010' git config --global user.email 'charlesmaxwellyoung@gmail.com' npm i -g hexo-cli npm i - name: blog publish run: | hexo g -d push 上去，然后进入action 选项，观察状态。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[]},{"title":"javascript 执行机制流程","slug":"how-to-call-javascript","date":"2019-07-13T14:41:56.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"how-to-call-javascript.html","link":"","permalink":"https://vineo.cn/how-to-call-javascript.html","excerpt":"要了解 js 执行机制：首先我们先弄清楚两点： JavaScript是单线程的语言。 Event Loop是javascript的执行机制。","text":"要了解 js 执行机制：首先我们先弄清楚两点： JavaScript是单线程的语言。 Event Loop是javascript的执行机制。 js执行机制","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://vineo.cn/tags/javascript/"}]},{"title":"promise 冷知识","slug":"promise-summary","date":"2019-07-02T23:28:59.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"promise-summary.html","link":"","permalink":"https://vineo.cn/promise-summary.html","excerpt":"promise 总结 promise 属于宏任务","text":"promise 总结 promise 属于宏任务 promise 构造函数是同步，而 then 是异步的 123456console.log('a')new Promise(() =&gt; &#123; console.log('b')&#125;)console.log('c')// 执行结果是a,b,c promise 状态不可逆 then|catch|return出去的数值会被后面的then或者catch接受（我们可以利用此特性，来进行链式调用） promise 无论返回什么，都会被封装的成 promise 对象，即使返回一个对象 使用then 进行接收，如果里面不是函数，会发生穿透 promise 对象中的resolve或者reject 一个promise对象，那么前一个promise 会影响后面一个promise es7 的async async 函数会返回一个promise函数 return 错误会让返回promise对象变为reject 一般来说 await 后面的值是一个promise 内部如果await 多个promise，则会等待所有promise执行完成才会执行then","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://vineo.cn/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"https://vineo.cn/tags/promise/"}]},{"title":"window 操作系统，安装 mongodb.zip 包","slug":"install-mongodb-window","date":"2018-12-13T22:06:05.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"install-mongodb-window.html","link":"","permalink":"https://vineo.cn/install-mongodb-window.html","excerpt":"安装mongodb.msc文件时，最后一步总是报错，告诉你服务安装失败。于是下载了mongodb ZIP包；也就是绿色版本，进行安装！","text":"安装mongodb.msc文件时，最后一步总是报错，告诉你服务安装失败。于是下载了mongodb ZIP包；也就是绿色版本，进行安装！ 下载 下载链接 ​ 参照自己的window版本，下载对应的 zip 包。 观察下载目录是不是这样的？ 创建目录 在自己磁盘中创建一个文件名字随便起，文件中创建三个文件夹分别为：data,etc,logs，结合上个，完整目录为： 123456789mongodb #主文件夹 data #用来存在数据库 etc #用来存储配置文件 logs #存在mongodb 日志文件 bin # mongodb的执行文件 LICENSE-Community.text MPL-2 README THIRD-PARTY-NOTICES 写一个配置文件mongo.conf，在文件中添加内容： 123456dbpath=D:\\mongodb\\data #数据库路径 logpath=D:\\mongodb\\logs\\mongo.log #日志输出文件路径 logappend=true #错误日志采用追加模式 journal=true #启用日志文件，默认启用 quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false port=27017 #端口号 默认为27017 注意：dbpath和logpath。这个是根据你的文件夹路径写的 ​ 最终结果如下： ​ 启动 为了能够全局使用mongodb一些命令，我们配置path环境。 添加mongodb 服务 1mongod --dbpath \"D:\\mongodb\\data\\db\" --logpath \"D:\\mongodb\\logs\\MongoDB.log\" --install --serviceName \"MongoDB\" 启动服务 1net start MongoDB 在浏览器中输入http://127.0.0.1:27017/，如果有以下显示说明启动成功！ 启动mongodb ​ 最后自己开始弄mongodb，数据操作。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://vineo.cn/tags/mongodb/"}]},{"title":"如何为你的 angular app构建一个第三方库","slug":"how-to-build-lib-ng","date":"2018-11-21T00:10:03.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"how-to-build-lib-ng.html","link":"","permalink":"https://vineo.cn/how-to-build-lib-ng.html","excerpt":"完整指南 Angular 团队 在 angular6 中，使得创建 Angular 第三方库变得更为简单。如果你以前尝试过操作，你会发现其实不是很简单！","text":"完整指南 Angular 团队 在 angular6 中，使得创建 Angular 第三方库变得更为简单。如果你以前尝试过操作，你会发现其实不是很简单！ 那么流程是什么呢？ 首页我们构建一个搭建一个简单的环境，环境里面包含一些组件和服务以及一些接口。 创建项目1.按照官方教程，使用ng new命令初始化项目： 1ng new lib-demo --prefix ld 在 angular-cli **第6个之后版本。配置文件的方式发生了相当大变化，angular.json现在代表angular**工作空间, 你可以可以使用ng generate application [my-app-name]命令添加更多项目 你也可以通过 ng generate指令创建一个公共库。 1ng generate library tvmaze --prefix tm 当然你可以使用简写命令 1ng g lib tvmaze --prefix tm 具体参照 使用generate在我们angular.json中添加一个项目。 在库中创建一个服务我们会发现tvmaze有它自己的package.json，tsconfig.json，tslint.json和karma.conf.js，这样建立是有原因的，因为这个项目独立与主应用建立而成，它本身也有组件、服务、模块。稍后我们添加其他的内容。现在我们添加一些逻辑： 这里说明下provideIn: root是angular6 之后的新属性，详情见官网；如果是为了打包优化。 在库中创建一个组件我们使用angular-cli 来创建一个组件 12# 使用--project 指定创建在那个工程中ng generate component poster --project=tvmaze 然后这样编辑 将组件注册到TvmazeModule中，并且exports中是的外部能够访问，还得添加 CommonModule,HttpClientModule两个模块。 构建一下在我们使用之前，我们先构建一下，我们ng build构建，指定项目。 1ng build tvmaze 使用库接下来，我们来使用刚刚构建好的库，一般我们采用第三方库都是使用import来导入。 我们会发现库不存在。因为这种方式，它是从node_modules寻找，所以我们要在根目录下tsconfig.json添加paths 接下来我们在主项目中运用：使用&lt;tm-poster&gt;标签，即可完成 发布到npm中去我们直接使用以下命令：前提是你注册npm账号 123ng build tvmazecd dist / tvmaze npm publish","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[{"name":"angular","slug":"angular","permalink":"https://vineo.cn/tags/angular/"}]},{"title":"python 学习(五)","slug":"python-learn5","date":"2018-11-13T23:54:08.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"python-learn5.html","link":"","permalink":"https://vineo.cn/python-learn5.html","excerpt":"字典,类似于javascript 中的map 对象","text":"字典,类似于javascript 中的map 对象 创建和使用字典 dict 函数 字典可以用下面的创建 字典的 key 值是唯一的。 1phoneBook = &#123;\"bill\":\"1234\",\"MIKE\":\"312312\"&#125; 可以用 dict 函数，通过其他映射（如其他的字段）或简直对的序列建立字典 第一个值表示 key，第二个值标识 value 123items = [[\"billl\",\"21312321\"],(321321,\"3213\"),[\"martty\",\"dsada\"]]print(dict(items))&gt;&gt;&gt; &#123;'billl': '21312321', 321321: '3213', 'martty': 'dsada'&#125; dict 函数还可以通过关键字参数来创建字典 如果 dict 函数如果不指定参数，那么该函数会返回一个空的字典 123a = dict(name=\"312321\", number=\"222\", age=111)print(dict(a))&gt;&gt;&gt; &#123;'name': '312321', 'number': '222', 'age': 111&#125; 字典的基本操作 如下： 1234567dict = &#123;&#125; # 定义一个字典dict[20] = \"Bill\" # 向字典 dict 中添加整数类型的keydict[\"Mike\"] = &#123;'age': 30, \"salary\": 3000&#125; # 向字典 dict 中添加字符串的keydict[(12, \"Mike\", True)] = \"hello\" # 向字典 dict 中添加元组类型的keyprint(dict)&gt;&gt;&gt; &#123;20: 'Bill', 'Mike': &#123;'age': 30, 'salary': 3000&#125;, (12, 'Mike', True): 'hello'&#125; in 操作，检查 dict 中是否包含有健为 key的项，只能查找 key ，不是 value1234567891011121314151617181920212223Demo = &#123; \"sublime\": &#123; \"language\": [\"java\", \"python\"], \"org\": \"sublime 开源\" &#125;, \"webstorm\": &#123; \"language\": [\"python\", \"php\"], \"org\": \"webstorm 基金会\" &#125;, \"vs code\": &#123; \"language\": [\"javascript\"], \"org\": \"javascript 开源\" &#125;&#125;de = input(\"请输入的编辑器名字\")de1 = de.replace(\" \", \" \").lower()# 检查 dict 中是否包含有健为 key 的项if de1 in Demo: print(Demo[de1])&gt;&gt;&gt; 请输入的编辑器名字webstorm &#123;'language': ['python', 'php'], 'org': 'webstorm 基金会'&#125; 字典的格式化字符串 对字典对字符串进行格式化，并且使用元组和%对字符串进行格式化的方式对比 使用%和元组格式化字符串 1234values = (1, 3, \"dsada\")str1 = \"%d dsada, xyt %d, %s world\"print(str1 % values)&gt;&gt;&gt; 1 dsada, xyt 3, dsada world 定义字符串模板 format_map方法使用的字符串模板中，格式化采用一对花括号{},如果格式化模板中的格式化参数在字典中为找到，系统会抛出异常。 1234567891011121314151617181920values1 = &#123;\"title\": \"webstorm\", \"url\": \"https://www.baidu.com\"&#125;str2 = \"\"\"&lt;html&gt; &lt;title&gt;&#123;title&#125;&lt;/title&gt; &lt;body&gt; &lt;a href=\"&#123;url&#125;\"&gt;&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;\"\"\"print(str2.format_map(values1))&gt;&gt;&gt;&lt;html&gt; &lt;title&gt;webstorm&lt;/title&gt; &lt;body&gt; &lt;a href=\"https://www.baidu.com\"&gt;&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 序列与迭代 获取字段中key的列表 12345678dict = &#123;\"x\": 1, \"y\": 2, \"z\": 7&#125;for a in dict: print(a)&gt;&gt;&gt;xyz 同时获取字典中的key和value列表 使用字典中的items方法，转换为元组的序列 dict_items([(&#39;x&#39;, 1), (&#39;y&#39;, 2), (&#39;z&#39;, 7)]) 123456for a, y in dict.items(): print(a, y)&gt;&gt;&gt;x 1y 2z 7 并行迭代 同时迭代的两个或多个序列,用range函数获取序列索引的范围 123456names = [\"bill\", \"marry\", \"john\"]ages = [30, 40, 60]for i in range(len(names)): print(names[i], ages[i], end=\" \")&gt;&gt;&gt; bill 30 marry 40 john 60 压缩序列 这里的压缩序列值的使用zip函数，将两个或者多个序列的对应的元素作为一个元组放在一起，如果压缩的两个或者多个序列的元素个数不相同，以元素个数少的为准。 1234567a = [\"dsa\", \"测试1\", \"测试机哦i2\"]b = [\"httos/ldasd\", \"hjttps:&gt;dedsa\", \"123213125dsa\", \"ccccccc\"]print(zip(a, b))for c in zip(a, b): print(c, end=\" \")&gt;&gt;&gt; ('dsa', 'httos/ldasd') ('测试1', 'hjttps:&gt;dedsa') ('测试机哦i2', '123213125dsa') 字典中的方法 clear 方法 1234567dict = &#123;\"a\": \"c\", \"b\": \"2\"&#125;dict.clear()print(dict)&gt;&gt;&gt; &#123;&#125; 注意点：clear方法，如果两个变量同时指向一个字典变量时，clear方法会同是清空指向的变量。如： 123456789101112dict = &#123;\"a\": \"c\", \"b\": \"2\"&#125;dict2 = dictdict = &#123;&#125;print(dict2)&gt;&gt;&gt; &#123;'a': 'c', 'b': '2'&#125;# 对比以下的dict = &#123;\"a\": \"c\", \"b\": \"2\"&#125;dict2 = dictdict.clear()print(dict2)&gt;&gt;&gt; &#123;&#125; copy 和 deepcopy 函数 copy 方法用于复制一个字典，该方法返回复制后的新字典 12345# 浅复制dict = &#123;\"a\": \"c\", \"b\": \"2\"&#125;dict2 = dict.copy()print(dict2)&gt;&gt;&gt; &#123;'a': 'c', 'b': '2'&#125; deepcopy函数用来解决 copy 中字典两层以下层的复制，也就说对于第二层，都是指向同一个值 不管修改原字典中的元素，还是修改复制之后的字典的元素，原字典和新字典中的元素都会改变。 12345678910111213141516171819 # 复制dict = &#123;\"a\": \"c\", \"b\": \"2\", \"c\": [\"1\", \"2\", \"3\"]&#125;dict2 = dict.copy()dict2[\"c\"][0] = 'c1'print('dict', dict)print('dict2', dict2)&gt;&gt;&gt; dict &#123;'a': 'c', 'b': '2', 'c': ['c1', '2', '3']&#125;dict &#123;'a': 'c', 'b': '2', 'c': ['c1', '2', '3']&#125;# 解决方案from copy import deepcopydict = &#123;\"a\": \"c\", \"b\": \"2\", \"c\": [\"1\", \"2\", \"3\"]&#125;dict2 = deepcopy(dict)dict2[\"c\"][0] = 'c1'print('dict', dict)print('dict2', dict2)&gt;&gt;&gt; dict &#123;'a': 'c', 'b': '2', 'c': ['1', '2', '3']&#125;dict2 &#123;'a': 'c', 'b': '2', 'c': ['c1', '2', '3']&#125; fromkey 方法 根据key建立新的字典，在新的字典中，所有key都有相同的默认值，默认值为None 12345678x = &#123;&#125;.fromkeys([\"name\", \"age\", \"salary\"])print(x)&gt;&gt;&gt; &#123;'name': None, 'age': None, 'salary': None&#125;# 第二参数，用于处理所有默认值x = &#123;&#125;.fromkeys([\"name\", \"age\", \"salary\"], \"默认值\")print(x)&gt;&gt;&gt; &#123;'name': '默认值', 'age': '默认值', 'salary': '默认值'&#125; get 方法 get 方法用于更宽松的方式从字典中获取 key 的 value，一般我们获取一个采用，dict[key]，如果 value 不存在，则会报错。 我们可以采用以下的方法： 123x = &#123;&#125;.fromkeys([\"name\", \"age\", \"salary\"], \"默认值\")print(x.get(\"cxcc\", 0))&gt;&gt;&gt; 0 items **和key** 方法 items 用来返回字典中所有的 key-value对。key 用来返回 12345x = &#123;&#125;.fromkeys([\"name\", \"age\", \"salary\"], \"默认值\")print(x.items())&gt;&gt;&gt; dict_items([('name', '默认值'), ('age', '默认值'), ('salary', '默认值')])print(x.keys())&gt;&gt;&gt; dict_keys(['name', 'age', 'salary']) pop **方法和popitem **方法 用于弹出字典中元素，pop 用于指定key的弹出,key-value 键值对，popitem 弹出最后一个 key-value 键值对。 12345x = &#123;&#125;.fromkeys([\"name\", \"age\", \"salary\"], \"默认值\")print(x.pop(\"name\"))&gt;&gt;&gt; 默认值print(x.popitem())&gt;&gt;&gt; ('salary', '默认值') setdefault 方法 用户设置字典的 key 的默认值，接受两个参数，第一个为 key，第二个为 value 1234567891011x = &#123;&#125;x.setdefault(\"name\", \"bill\")print(x)&gt;&gt;&gt;&#123;'name': 'bill'&#125;# 向x字典中添加age的keyx = &#123;&#125;x.setdefault(\"name\", \"bill\")print(x)x.setdefault(\"age\")print(x)&gt;&gt;&gt; &#123;'name': 'bill', 'age': None&#125; *update *方法 可以用一个字典中元素更新到另外一个字典。 123456789101112dict = &#123; \"title\": \"大飒飒\", \"website\": \"https://www\"&#125;dict2 = &#123; \"title\": \"大飒飒\", \"website\": \"https://www.vineo.cn\", \"copyright\": \"vineo\"&#125;dict.update(dict2)print(dict)&gt;&gt;&gt; &#123;'title': '大飒飒', 'website': 'https://www.vineo.cn', 'copyright': 'vineo'&#125; *value *方法 用迭代器的方式返回字典中的值。 12345678910111213dict = &#123; \"title\": \"大飒飒\", \"website\": \"https://www\"&#125;dict2 = &#123; \"title\": \"大飒飒\", \"website\": \"https://www.vineo.cn\", \"copyright\": \"vineo\"&#125;dict.update(dict2)print(dict.values())&gt;&gt;&gt;dict_values(['大飒飒', 'https://www.vineo.cn', 'vineo']) 总结字典是一个重要的序列形式，主要根据key查询value。经常被用到需要快速查找定位，但是数据量不是很大的数据的场景。","categories":[{"name":"学习","slug":"学习","permalink":"https://vineo.cn/categories/学习/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://vineo.cn/tags/PYTHON/"}]},{"title":"python 学习(四)","slug":"python-learn4","date":"2018-11-06T23:40:33.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"python-learn4.html","link":"","permalink":"https://vineo.cn/python-learn4.html","excerpt":"所有序列操作对于字符串是同样适用，我们可以理解为将字符串里面的字符看成是序列的一个一个的元素。","text":"所有序列操作对于字符串是同样适用，我们可以理解为将字符串里面的字符看成是序列的一个一个的元素。 格式化字符串字符串中最核心的功能就是格式化操作。 字符串格式化基础 字符串格式话相当于字符串模板。通俗的讲就是，字符串中一段是固定而另一端是动态变化的。 那么固定的模块，我们称之为模板；动态的可以用%来替换。 例如： 12345formatStr = 'hello %s.this is %s world'values = ('sisi', 'sisi')print(formatStr % values)&gt;&gt;&gt;hello sisi.this is dasdad world 字符串模板指定格式化参数时，要使用%,指定字符串格式化参数值要使用元组。 使用%f来表示浮点类型的格式化参数 123456789101112131415161718# 定义格式化模板from math import piformatStr = 'PI是圆周率，%.4f -----&gt;保留小数点%d位'values = (pi, 4)print(formatStr % values)&gt;&gt;&gt; PI是圆周率，3.1416 -----&gt;保留小数点4位formatStr1 = '%s的成功率%d%%'values1 = ('思思', 100)print(formatStr1 % values1)&gt;&gt;&gt; 思思的成功率100%values2 = ('思思')print(formatStr1 % values2)&gt;&gt;&gt; 参数值的数量要和格式化参数不匹配，error 记得参数值的数量要和格式化参数要匹配，不然会报错 模板字符串 在String模块中提供了一个用于格式化的字符串template的类，用来处理同一个值替换所有的相同格式化参数。 template格式化参数，用$符号来开头，后面接着格式化名称。 123456from string import Templatea = Template('$ccc是我最喜欢的$ccc还是$ccc')print(a.substitute(ccc=\"python\"))&gt;&gt;&gt; python是我最喜欢的python还是python 当格式化参数是一个字符串一部分时，需要用{}来区分。 123b = Template('$&#123;abv&#125;RING')print(b.substitute(abv='sub'))&gt;&gt;&gt; subRING 字符串中format方法 使用一对{},而且支持按顺序指定格式化参数值和关键字格式化参数 12print(\"&#123;&#125; &#123;&#125; &#123;&#125;\".format(1, 2, 3))&gt;&gt;&gt; 1 2 3 可以命名格式化，可以在一对大括号中指定一个名称 12print(\"&#123;a&#125; &#123;b&#125; &#123;c&#125;\".format(a=1, b=2, c=3))&gt;&gt;&gt; 1 2 3 混合顺序格式化参数和关键字格式化参数两种 123456a3 = \"today is &#123;week&#125;,&#123;&#125;, the&#123;&#125; temperature is &#123;degree&#125; degrees\"# 这个方式是错的a3.format(week=\"31231\", \"dasdas\", 1231231, degree=\"dadsa\")# 前面应该是按照书讯传递格式化参数值，后面是关键字格式化参数值，顺序是不能调换print(a3.format(\"dadasa\", 1231312, week=\"sunday\", degree=22))&gt;&gt;&gt; today is sunday,dadasa, the 1231312 temperature is 22 degrees 为顺序格式化参数指定了从format方法获取参数值的顺序，{1}表示从 format 方法的第2个参数取值{0}表示从 format 方法的第1个参数取值 123a4 = \"today is &#123;week&#125;,&#123;1&#125;, the &#123;0&#125; temperature is &#123;degree&#125; degrees\"print(a4.format(\"dadasa\", 1231312, week=\"sunday\", degree=22))&gt;&gt;&gt; today is sunday,1231312, the dadasa temperature is 22 degrees 列表格式化 1234fullname = [\"bill\", \"gates\"]# print(\"Mr &#123;name[0]&#125;\".format(name=fullname))&gt;&gt;&gt;Mr bill 导入math模块,访问 math 模块中的__name__变量来获取模块的名字，访问 math中的PI的变量获取PI的值 123s5 = \"the &#123;mod.__name__&#125; module defines the value &#123;mod.pi&#125; for pi\"print(s5.format(mod=math))&gt;&gt;&gt;the math module defines the value 3.141592653589793 for pi 更进异步的控制字符串格式化参数 123456print(\"&#123;first!s&#125; &#123;first!r&#125; &#123;first!a&#125;\".format(first=\"中文\"))&gt;&gt;&gt;中文 '中文' '\\u4e2d\\u6587'a6 = \"&#123;number1:E&#125;\"print(a6.format(number1=1234567789))&gt;&gt;&gt;1.234568E+09 类型符 描述 a 将字符串按Unicode编码输出 b 将一个整数格式化为一个二进制书 c 将一个整数解释称ASCII d 将整数格式化十进制的整数 e 将十进制格式化科学计数法，用e表示 E 将十进制格式化科学计数法，用E表示 f 将十进制格式化格式化浮点数。会将特殊值（nan和inf）转换为小写 F 将十进制格式化格式化浮点数。会将特殊值（nan和inf）转换为大写 g 会根据整数值的位数，在浮点数和科学计数法之间，在整数为超过6位时，与e相同否则相同 E 会根据整数值的位数，在浮点数和科学计数法之间，在整数为超过6位时，与E相同否则相同 o 将一个整数格式化为八进制 s 按照原样输出 x 将一个整数格式化为十六进制，字母小写 X 将一个整数格式化为十六进制，字母大写 % 将数值格式化为百分比形式 其中inf 表示无穷大，NAN可解释为非数字。 字段宽度，精度和千位分隔符123456789101112131415#显示宽度为12，会在52的左侧会有10空格print(\"&#123;num:12&#125;\".format(num=\"52\"))&gt;&gt;&gt; 52#52右侧显示6个字符print(\"&#123;num1:12&#125;Grate\".format(num1=\"52\"))&gt;&gt;&gt;52 Grate#保留pi的小数点后面两位print(\"float number:&#123;pi:.2f&#125;\".format(pi=pi))&gt;&gt;&gt;float number:3.14#将精度应用与字符串，截取前五位字符print(\"&#123;:.5&#125;\".format(\"hello world\"))&gt;&gt;&gt;hello#用千分位分隔符输出googolprint(\"one googol is &#123;:,&#125;\".format(10 ** 1000))&gt;&gt;&gt;one googol is 10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000... 字符串方法常用的字符串方法有 center find join split lower upper capwords replace 等 center方法 将字符串进行居中，center方法有两个参数。第一个参数是数字类型，表示字符串显示的宽度，第二可选的，用来添加填充的符号 123456print(\"&lt;\" + \"hello\".center(30) + \"&gt;\")print(\"&lt;&#123;:^30&#125;&gt;\".format(\"hello\"))&gt;&gt;&gt; &lt; hello &gt;print(\"&lt;\" + \"hello\".center(30, \"&amp;\") + \"&gt;\")print(\"&lt;&#123;:&amp;^30&#125;&gt;\".format(\"hello\"))&gt;&gt;&gt; &lt;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;hello&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&gt; find 方法 1234567891011s = \"hello world\"print(s.find(\"w\"))&gt;&gt;&gt;6 #第一次出现的“w”的位置，如果没有找到放回-1s = \"hello world\"print(s.find(\"o\", 5))&gt;&gt;&gt; 7 #指定开始的查找的位置s = \"hello world\"print(s.find(\"l\", 5, 9))&gt;&gt;&gt; -1 #指定结束位置，第8个位置 join操作方式和js操作方式相似（注意一点就是，序列元素必须是字符串类型） split 和join互斥 lower 将字符串小写，upper大写,capwords首字母大写 12345678s = \"hello world\"print(s.lower())&gt;&gt;&gt; hello worldprint(s.upper())&gt;&gt;&gt; HELLO WORLDprint(string.capwords(s))&gt;&gt;&gt;Hello World replace 方法，将字符串替换成另外一个字符串。 12print(\"this is a car\".replace(\"car\", \"bike\"))&gt;&gt;&gt; this is a bike strip方法，截取字符串的前后空格。 12345print(\" geeodedasdasd.dasdasd\".strip())&gt;&gt;&gt; geeodedasdasd.dasdasd# 指定截取字符串前后字符的空格、* &amp;print(\"*** &amp;* Hello &amp; *World **&amp;&amp;\".strip(\" *&amp;\"))&gt;&gt;&gt; Hello &amp; *World translate方法 translate 方法和 replace 方法类似，都是用来替换字符串中的某一部分，不同点在于translate 用来替换单个字符，而replace方法可以用来一个字符串，效率上translate ，更高。 总结了解字符串的格式化和字符串方法。","categories":[{"name":"学习","slug":"学习","permalink":"https://vineo.cn/categories/学习/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://vineo.cn/tags/PYTHON/"}]},{"title":"为你博客添加disqus评论系统","slug":"config-disqus","date":"2018-10-31T00:00:00.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"config-disqus.html","link":"","permalink":"https://vineo.cn/config-disqus.html","excerpt":"前言博客做了有一段时间了，写了一些文章；想想写了这些东西，关键没有人评论，总感觉是自己一个人在对着自己说话，始终空落落的。因此自己就得整个评论的。于是乎，到找找国内评论的，发现好多的都要关闭了；不知道是什么原因。","text":"前言博客做了有一段时间了，写了一些文章；想想写了这些东西，关键没有人评论，总感觉是自己一个人在对着自己说话，始终空落落的。因此自己就得整个评论的。于是乎，到找找国内评论的，发现好多的都要关闭了；不知道是什么原因。 因此自己搭了一个梯子去国外网站去看看。发现了一个新大陆disqus 开始1.任何网站都的从注册开始，这个网站也是这样的。 注册，如图(记得自己弄梯子)： 登录完成之后，他会显示一下页面，我们点击箭头所指方向 进入之后，输入一些信息,然后点击 create site 它会询问你，一些服务资费，这里我们选择基础的，也就是免费。（当然土豪可以忽略） 由于我的博客是 jekyll 所以这里我选择 jekyll 我们配置一下 disqus 一些配置，然后点击 complete Setup 至此我们流程已经50%了，接下 我们选择下要配置的网页 最后我们就可以看到一个关键点 shortname,然后点击保存 2.上面的几步只是注册一些东西，我们接下来还要集成到我们自己博客中。 一般在你的博客的文章下方下方复制这段代码1234567891011121314&lt;div id=\"disqus_thread\"&gt;&lt;/div&gt;&lt;script&gt;var disqus_config = function () &#123; this.page.url = '&#123;&#123; page.url | absolute_url &#125;&#125;'; this.page.identifier = '&#123;&#123; page.url | absolute_url &#125;&#125;';&#125;;(function () &#123; var d = document, s = d.createElement('script'); s.src = 'https://&#123;&#123; page.url &#125;&#125;.disqus.com/embed.js\"; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); &#125;)();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the comments.&lt;/noscript&gt; 最终效果","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[{"name":"disqus","slug":"disqus","permalink":"https://vineo.cn/tags/disqus/"}]},{"title":"python 学习(三)","slug":"python-learn3","date":"2018-10-30T00:00:00.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"python-learn3.html","link":"","permalink":"https://vineo.cn/python-learn3.html","excerpt":"基础知识 在python中最基本的数据结构是序列。系列的每一个元素都被分配一个编号，可以称这个编号是索引。自己可以理解为其他语言的数组 序列","text":"基础知识 在python中最基本的数据结构是序列。系列的每一个元素都被分配一个编号，可以称这个编号是索引。自己可以理解为其他语言的数组 序列 1.创建序列创建一个序列： 1a = [1, 3, \"3\", True] 序列的内部值是任意类型的值 创建二维序列： 1v = [1, 3, 45, [1, \"4324\"]] 2.序列的基本操作 和其他语言一样，序列都是下标的。 1234a = [1, 3, \"3\", True]print(a[1])&gt;&gt;&gt;3 可以通过索引获取字符串s中，相对应的位置的字符，类似js操作 1234s = 'hello world'print(s[2])&gt;&gt;&gt;l 如果索引为负数，则获取序列的倒数第一和第二，例如： 12345678s = [\"bill\", 'mary', 'jack']print(s[0])print(s[-1])print(s[-2])&gt;&gt;&gt;billjackmary 如果下标超出范围，则会抛出异常 3.分片分片操作是从序列A中获取一个子序列B。 基本操作如下： 1234s = \"https://vineo.cn\"print(s[1:3])&gt;&gt;&gt;tt 通过索引和省略索引的方式得到子序列，观察下面一个例子： 1234567891011121314151617181920a = [1, 2, 3, 4, 5, 6, 7, 8]print(a[3:5])print(a[0:1])print(a[5:8])print(a[-3:-1])print(a[-3:0]) #python语言规定，如果结束索引比开始索引晚出现，那么就会返回一个空序列。print(a[-3:]) #省略了结束索引 ---&gt;print(a[-3:-1])print(a[-3:8]) #结束索引用了正数作为索引print(a[:3]) #表示序列的前三位子序列print(a[:]) #如果不指定任何序列，则复制整个序列&gt;&gt;&gt;[4, 5][1][6, 7, 8][6, 7][][6, 7, 8][6, 7, 8][1, 2, 3][1, 2, 3, 4, 5, 6, 7, 8, 9] 设置步长，可以用来获取不相邻的元素 12345678910a = [1, 2, 3, 4, 5, 6, 7, 8]print(a[1:6:2]) #指定每次跨几步，格式是： a[开始索引:结束索引:步长]print(a[::2]) #可以省略开始和结束索引print(a[3::2])print(a[::-2]) #从后往前推&gt;&gt;&gt;[2, 4, 6][1, 3, 5, 7, 9][4, 6, 8][9, 7, 5, 3, 1] 注意：步长不能为0，负责会抛出异常。如果步长为负数，此时开始索引要比结束索引要大。 小结： 12345678urls = input(\"请输入一个网址\")print(\"输入的scheme：\", urls[0:5])print(\"输入的host：\", urls[8:])&gt;&gt;&gt;请输入一个网址https://www.vineo.com输入的scheme： https输入的host： www.vineo.com 序列相加1234567print([1, 3, 4] + [5, 67])print([1,2,3]+[\"hrlloe\"])print([1,2,3]+[\"hrlloe\",\"23231\",54])&gt;&gt;&gt; [1, 3, 4, 5, 67] [1, 2, 3, 'hrlloe'] [1, 2, 3, 'hrlloe', '23231', 54] 序列不能和字符串相加，不然会出现异常 序列相乘 12345print('hello' * 5)print([1,3,4]*5)&gt;&gt;&gt;hellohellohellohellohello[1, 3, 4, 1, 3, 4, 1, 3, 4, 1, 3, 4, 1, 3, 4] 序列的长度（len），最大值（max）和最小值（min） 12345678a = [34, 32, 4, 5123, 3232, 567, 89, 2, 2]print(len(a))print(max(a))print(min(a))&gt;&gt;&gt;951232 注意点，序列中每一个值都是具有可比性，不然Python会报错 123&gt; a = [\"dsada\",2]&gt; print(min(2)) # 报错&gt; 4.列表的操作 列表的元素赋值 12345a = [34, 32, 4, 5123, 3232, 567, 89, 2, 2]a[2] = \"9\"print(a)&gt;&gt;&gt;[34, 32, '9', 5123, 3232, 567, 89, 2, 2] 注意点：赋值的索引可以是正数或者是负数，但是数值不能超过列表的索引的范围 列表元素的删除（del） 12345a = [34, 32, 4, 5123, 3232, 567, 89, 2, 2]del(a[1])print(a)&gt;&gt;&gt;[34, 4, 5123, 3232, 567, 89, 2, 2] 分片赋值操作分片赋值和分片获取字列表一样，也需要指定分片操作，也就是需要指定要操作的列表的范围。 1234567891011121314# 将从列表的第一位开始替换元素，并且生成一个新的列表a = [\"hello\", \"world\", \"python\"]a[1:] = [\"a\", \"b\", \"c\"]print(a)# 使用list函数，将字符串转换为列表a= list(\"mick\")print(a)a[1:] = \"ary\"print(a)&gt;&gt;&gt;['hello', 'a', 'b', 'c']['m', 'i', 'c', 'k']['m', 'a', 'r', 'y'] 从上面的代码中，使用了分片，替换完成的子列表，可以是长度可以是不相同的。 因此我们可以以上特性，可以实现列表的数组的新增和删除。 12345678910a = [2, 3, 45, 6]a[1:1] = [\"das\", \"ok\", 23]print(a)a[1:3] = []print(a)&gt;&gt;&gt;[2, 'das', 'ok', 23, 3, 45, 6][2, 23, 3, 45, 6] 如果冒号前后数值相同，则表示不替换列表中任何元素。 5.列表方法先来明确一个概念：函数和方法，函数是全局，而方法是定义在一个类中的。 方法名 说明 append 在列表最后插入新值 clear 清除列表内容 copy 复制一个列表 count 统计列表中某个元素的出现的次数 extend 在列表结尾插入一个新列表，类似于相加。不同点在于extend改变的是原列表，而相加得到一个新列表 index 获取元素在列表中第一次出现的索引数 insert 插入列表中指定的位置 pop 移除列表中的元素(默认移除最后一位元素)，并且返回改元素值 remove 移除列表中某个值的第一次匹配项 reverse 将列表的元素进行反向存放 sort 对列表进行排列，但是会改变原来的列表 6.元组元组和列表一样，也是一种序列。不同点在于元组不能修改，它是只读属性，只需要用,分隔值即可。例如 123456789101112131415a = 1, 3, 4, 5, 6print(a)&gt;&gt;&gt; (1, 3, 4, 5, 6)() # 创建一个空元组print(5*(12+4,)) # 生成5个同样值的元组&gt;&gt;&gt;(16,16,16,16,16)print(5*(12+4)) #一个数值&gt;&gt;&gt;80array = [1,4,5,6]tuple(array) #可以使用tuple函数将列表转换为元组","categories":[{"name":"学习","slug":"学习","permalink":"https://vineo.cn/categories/学习/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://vineo.cn/tags/PYTHON/"}]},{"title":"python 学习(二)","slug":"python-learn2","date":"2018-10-23T00:00:00.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"python-learn2.html","link":"","permalink":"https://vineo.cn/python-learn2.html","excerpt":"基础知识print函数","text":"基础知识print函数 表示打印 print可以传入多个参数，那么相对应的首尾输出。(可以理解chrome 浏览中console函数)例如: 12print(1, 3, 4, 5, 6, 7)&gt;&gt;&gt;1 3 4 5 6 7 当我们输出print(&quot;apple&quot;, &quot;,&quot;, &quot;orange&quot;)返回的结果有空格；apple , orange。解决方法: 1234567print(\"apple\"+\",\"+\"orange\")&gt;&gt;&gt;apple,orange# 采用print特有的方法，就是priny函数最后参数添加sep=\",\"print(\"apple\", \"orange\", \"banana\", sep=\",\")&gt;&gt;&gt;apple,orange,banana print函数输出结果，结果后面会默认添加一个\\n换行符，可以通过end=&quot;&quot;参数，引号中可以添加参数可以添加参数例如： 1234567x = 12345y = 0xF98Az = 0b1100010110print('2', bin(x), end=\"|\")print('8', oct(x), end=\"|\")print('16', hex(x), end=\"|\")&gt;&gt;&gt;2 0b11000000111001|8 0o30071|16 0x3039| 赋值操作 = python可以多个赋值操作 123456x, y, z = 12345, 0xF98A, 0b1100010110print('2', bin(x), end=\"|\")print('8', oct(x), end=\"|\")print('16', hex(x), end=\"|\")&gt;&gt;&gt;2 0b11000000111001|8 0o30071|16 0x3039| python 这种赋值方式，称之为序列解包，确保左右赋值相同，不然会报错。 链式赋值 123a = b = 9print(a, b)&gt;&gt;&gt;9 9 增量赋值 123456789101112a = b = 9a *= 2 # ===&gt; a=a*2print(a)&gt;&gt;&gt;19a /= 2 # ===&gt; a=a/2print(a)&gt;&gt;&gt;4.5a %= 2 # ===&gt; a=a%2print(a)&gt;&gt;&gt;1 用缩进创建代码块 虽然tab也是可以进行缩进代码块，python将一个tab字符解释到下一个tab字符位置移动，而一个tab字符是8个字符，python推荐使用4个空格来进行缩进。 因此整个代码格式如下： 12345this is a codethis is a second code: this is block this is second block this is escaped the inner block 条件语句（逻辑控制）boolean 和boolean 变量 boolean变量：True和False,注意大小写。 下面的值会被解释为False：None 0 &quot;&quot; () [] {}。 在python底层，是将Flase看成0，True看成1，例如： 1234print(True == 1)&gt;&gt;&gt;Trueprint(False == 0)&gt;&gt;&gt;True 可以bool将一些变量，转换为boolean值。 1234print(bool(\"\"))&gt;&gt;&gt;Falseprint(bool(\"1\"))&gt;&gt;&gt;True 条件语句（if,else 和elif） 和其他语言对比： if和else 和其他语言用法相似， elif相当与其余语言的else if用法。 注意一点：python中没有switch逻辑判断语句。 基本用法和java和JavaScript用法相似。支持嵌套 比较运算符 逻辑表达式 描述 x==y x等于y x&lt;y x小于y x&gt;y x大于y x&lt;=y x小于等于y x&gt;=y x大于等于y x!=y x不等于y x is y x 和 y是同一个对象 x is not y x 和 y是不同一个对象 x in y x是y的容器的成员，如：y =[1,3,54,6] x=1 ; x in y &gt;&gt;&gt;True x not in y x是y的容器的成员，如：y =[1,3,54,6] x=12 ; x not in y &gt;&gt;&gt;True x or y x 或y x and y x 且y python 比较字符串时，会比较字符串的ASCII,如： 12print(\"hello\" &gt; \"Hello\")&gt;&gt;&gt;True 会首先比较h和H的 ASCII值，前面为真后面就不会比较 如果一个字符串是另一个字符串的前缀，那么python会认为字符串较长的更大一些 12print(\"hello\" &gt; \"hello world\")&gt;&gt;&gt;False 判断相等 123456789101112x = y = [1, 2, 3]z = [1, 2, 3]print(x == y)&gt;&gt;&gt; Trueprint(x == z)&gt;&gt;&gt; Trueprint(x is y)&gt;&gt;&gt; Trueprint(x is z)&gt;&gt;&gt; Falseprint(x is not z)&gt;&gt;&gt; True 可以参照类似堆和栈方式，来理解。 in和not in运算符 123456789x = [1, 2, 3]y = 3print(y in x)&gt;&gt;&gt;True#除了可以用来判断容器，也可以判断字符串是否包含其中一个字符串s = \"hello world\"print(\"h\" in s)&gt;&gt;&gt;True or和and用来表示多个逻辑的组合在一个。 断言 在python 语言中，要使用 assert 语句。 assert 后面指定断言的条件表达式，如果为False，就会抛出异常123456value = 20assert value &lt; 10 or value &gt; 30&gt;&gt;&gt;Traceback (most recent call last): File \"E:/webStromWorkSpace/python-learn/basic/test.py\", line 48, in &lt;module&gt; assert value &lt; 10 or value &gt; 30AssertionError 循环while循环1234567891011121314x = 1while x &lt;= 10: print(x) x += 1&gt;&gt;&gt;12345678910 for循环12345678910y = [1, 3, 4, 5, 6, 7, 8]for z in y: print(z)&gt;&gt;&gt; 1345678 跳出循环有时候，需要从循环体中跳出循环，这时我们就要用到break语句。例如： 123456789101112x = 0while x &lt; 100: if (x == 5): break print(x) x += 1&gt;&gt;&gt;01234 与break对应的，还有continue，表示结束本地循环。 不同点在于，continue会结束循环，后面循环还是继续的。 还有运用while语句时，要注意死循环的风险 在循环中使用else我们来观察一下代码： 123456789101112import randomx = 0flag = Falsewhile x &lt; 10: x += 1 if x == random.randint(1, 20): flag = True print(x) breakif not flag: print(\"没有中断while循环\") 从1-10，判断x是否等于 1-20 的随机数，如果相等，打印数字，否则输出没有中断while循环， 我们可以用else来处理 123456789101112131415161718192021import randomx = 0flag = Falsewhile x &lt; 10: x += 1 if x == random.randint(1, 20): flag = True print(x) breakelse: # while 循环的 else子语句 print(\"没有终端while循环\") numbers = [1, 2, 3, 4, 5, 6]for a in numbers: if a == random.randint(1, 20): print(a) breakelse: print(\"退出循环\") 使用exec和eval执行求职字符串1.exec类似JS的eval函数，可以将字符串当作JavaScript代码进行执行。python也有类似的功能，就是使用exec函数。 123exec(\"x=1\")exec(\"print(x)\")&gt;&gt;&gt;1 从代码中可以看到，执行两条语句，而且能够输出1，说明exec在python还能共享上下文，也就说通过python代码，与python解释器执行的方式是完全一样的。 还有一个注意点，尽可能不要用户全局作用下执行Python代码，否则可能会出现命名冲突现象。 2.eval和exec类似,不同点在于，eval用于执行表达式，并且返回结果；而exec并不会返回任何值。 1234scope = &#123;'x': 20&#125;arges = &#123;'y': 40&#125;print(eval('x+y', scope, arges))&gt;&gt;&gt;60","categories":[{"name":"学习","slug":"学习","permalink":"https://vineo.cn/categories/学习/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://vineo.cn/tags/PYTHON/"}]},{"title":"Intellij-IDEA配置JDK1.8","slug":"idea-JDK1.8","date":"2018-10-23T00:00:00.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"idea-JDK1.8.html","link":"","permalink":"https://vineo.cn/idea-JDK1.8.html","excerpt":"背景 Jdk 1.8支持Lambda新特性，想试试直接在IDEA使用，于是创建一个web项目，着手准备使用时，发现了以下的问题。环境已经中已经配置了jdk1.8环境","text":"背景 Jdk 1.8支持Lambda新特性，想试试直接在IDEA使用，于是创建一个web项目，着手准备使用时，发现了以下的问题。环境已经中已经配置了jdk1.8环境 解决方法 先打开idea的project structure配置 其次将所有的模块配置成为1.8环境，这样保证它的语法检测不报错，但是编译的时候他还是选择idea的默认配置，接下来更改编译配置 进入idea的设置页面，将编译模式改成1.8 异常问题如果缺少第三部，会出现如下错误 FAQ:设置完成之后，如果重新启动IDEA时，就会发现所有的设置又重新恢复到默认状态（JDK 1.5) 原因是： 12345Apache Maven Compiler PluginThe Compiler Plugin is used to compile the sources of your project. Since 3.0, the default compiler is javax.tools.JavaCompiler (if you are using java 1.6) and is used to compile Java sources. If you want to force the plugin using javac, you must configure the plugin option forceJavacCompilerUse.Also note that at present the default source setting is 1.5 and the default target setting is 1.5, independently of the JDK you run Maven with. If you want to change these defaults, you should set source and target as described in Setting the -source and -target of the Java Compiler. 解释是： 123456该插件从3.0版本开始，默认编译器是javax.tools.JavaCompiler （前提是JDK 1.6以后）；如果想使用javac，需要手动设置。当前（Version: 3.5.1），默认使用JDK 1.5解析和编译源码，与运行Maven的JDK版本无关！ PS: 12345678910111213141516171819&lt;project&gt; [...] &lt;build&gt; [...] &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; [...] &lt;/build&gt; [...]&lt;/project&gt; 解决方法：pom.xml中指定compiler的版本 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 当然还有一个简单写法 1234&lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[{"name":"JDK1.8","slug":"JDK1-8","permalink":"https://vineo.cn/tags/JDK1-8/"},{"name":"Intellij-IDEA","slug":"Intellij-IDEA","permalink":"https://vineo.cn/tags/Intellij-IDEA/"}]},{"title":"python 学习(一)","slug":"python-learn1","date":"2018-10-16T00:00:00.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"python-learn1.html","link":"","permalink":"https://vineo.cn/python-learn1.html","excerpt":"基础知识数字","text":"基础知识数字 加减乘除，以及圆括号运算 12345678910print(2+4)print(2*4)# 2的4次幂print(2**4)# 结果浮点print(4/2)# 余数print(4%3)# 结果取整print(4//3) 二进制，八进制，十六进制 表示三个进制数，必须以0开头，然后分别跟着不同进制的字母。b二进制，o是八进制，x十六进制。 123456789#例如： '''0 b 11 以0开头 表示进制 表示当前进制数字 ''' # 表示二进制 print(0b11) # 表示八进制 print(0o56) # 表示十六进制 二进制、八进制、十六进制相互转换 123456789101112print('十进制----&gt;二进制', bin(12345)) #----&gt; 十进制----&gt;二进制 0b11000000111001print('十进制----&gt;十六进制', hex(12345))#----&gt; 十进制----&gt;十六进制 0x3039print('十进制----&gt;八进制', oct(12345))#----&gt; 十进制----&gt;八进制 0o30071print('八进制----&gt;二进制', bin(0o30071))#----&gt; 八进制----&gt;二进制 0b11000000111001# 所有转换都类似 数字格式化输出（format 函数） format(x,y): x表示要格式的数字，y：表示格式字符串 123456789101112131415161718192021222324252627#例如x = 12341234.56789# 小数点保留后两位print(format(x, '0.2f'))# 数字在12个字符区域内右对齐，并保留小数点后一位数字print(format(x, '&gt;12.1f'))# 数字在12个字符区域内左对齐，并保留小数点后三位数字print(format(x, '&lt;12.3f'))# 每个千位，添加一个，print(format(x, ','))# 每个千位，添加一个，保留三位print(format(x, ',.3f'))# 科学计数法print(format(x, 'e'))# 科学计数法,保留2位print(format(x, '0.2e'))# 最终结果是：'''12341234.57 12341234.612341234.56812,341,234.5678912,341,234.5681.234123e+071.23e+07''' 输入input函数 1234567891011121314151617name = input(\"请输入名字\")age = int(input(\"请输入年龄\"))salary = float(input(\"请输入收入\"))print(name, \"姓名\")print(age, \"年龄\")print(salary, \"收入\")'''请输入名字1请输入年龄3请输入收入41 姓名3 年龄4.0 收入''' 注释 分为： 单行注释# 多行注释&#39;&#39;&#39;&#39;&#39;&#39;(单引号或者是双引号) 有时候我们需要确认文件的保存格式，可以采用单行注释来说明： 1# coding=utf-8 使用utf-8格式进行保存文件 单行注释和多行注释的用法 123456789101112# 科学计数法 单行注释''' 多行注释请输入名字1请输入年龄3请输入收入41 姓名3 年龄4.0 收入''' 字符串 在python世界里，&#39;&#39;和&quot;&quot;都可以用来表示字符串，和JavaScript一样。没有区别，只是习惯问题。 &#39;&#39;和&quot;&quot;没有区别 123print(\"hello world\")print('hello world')print('this\\'s is my world') 字符串拼接+ 123x='hello'y='world'print(x+y) 对于\\转义，和其他语言相似。具体可以参照javascript 长字符串&#39;&#39;&#39; &#39;&#39;&#39; 12345678910print(''''love'\"python\"''')'''输出，我们可以理解为js 中es6语法的``字符串'love'\"python\"'''","categories":[{"name":"学习","slug":"学习","permalink":"https://vineo.cn/categories/学习/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://vineo.cn/tags/PYTHON/"}]},{"title":"java类读取properties","slug":"java-class-read-properties","date":"2018-10-15T00:00:00.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"java-class-read-properties.html","link":"","permalink":"https://vineo.cn/java-class-read-properties.html","excerpt":"前言通过@value读取properties注意点","text":"前言通过@value读取properties注意点 applicationContext文件读取文件需要配置成为多文件读取方式 12345678910&lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;!-- jdbc配置 --&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;!-- 通用配置 --&gt; &lt;value&gt;classpath:config/appConfig.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 需要将java配置到service.impl中，就是需要spring service层级能够扫描到 12345678910111213141516171819202122232425262728293031@Component(\"commonConfig\")public class CommonConfig &#123; @Value(\"$&#123;config.isaKey&#125;\") private String isaKey; @Value(\"$&#123;config.doubankey&#125;\") private String doubanKey; @Value(\"$&#123;config.juheKey&#125;\") private String juheKey; @Value(\"$&#123;config.oneUuid&#125;\") private String oneUuid; public String getIsaKey() &#123; return isaKey; &#125; public String getDoubanKey() &#123; return doubanKey; &#125; public String getJuheKey() &#123; return juheKey; &#125; public String getOneUuid() &#123; return oneUuid; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://vineo.cn/categories/后端/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vineo.cn/tags/JAVA/"},{"name":"properties","slug":"properties","permalink":"https://vineo.cn/tags/properties/"}]},{"title":"npm 安装依赖失败","slug":"npm-install-error","date":"2018-10-15T00:00:00.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"npm-install-error.html","link":"","permalink":"https://vineo.cn/npm-install-error.html","excerpt":"前言 有时候，我们通过npm install进行项目初始化，会由于“天朝墙”的原因，可能会导致下载速度慢，无法下载等等问题出现。","text":"前言 有时候，我们通过npm install进行项目初始化，会由于“天朝墙”的原因，可能会导致下载速度慢，无法下载等等问题出现。 好在现在有很多国内镜像，也有一个帮助我们随意切换 npm 镜像的工具：nrm。 123456789101112npm install -g nrmnrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ nrm use taobao 现在我们将镜像切换成了淘宝： 1234567 npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/* taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ 但是有个弊端，当项目被其他人克隆后，每个人都要进行nrm，有点麻烦，可以在根目录创建添加 .npmrc 文件： 1234 sass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/electron_mirror=https://npm.taobao.org/mirrors/electron/registry=https://registry.npm.taobao.org 直接进行npm install 时，npm 都会根据跟目录下 .npmrc 中的配置进行依赖的安装。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://vineo.cn/tags/npm/"}]},{"title":"push to origin/master was rejected","slug":"git-error-resolve","date":"2018-10-15T00:00:00.000Z","updated":"2019-11-13T14:11:28.289Z","comments":true,"path":"git-error-resolve.html","link":"","permalink":"https://vineo.cn/git-error-resolve.html","excerpt":"push to origin/master was rejected错误解决方案idea中，发布项目到gitee的Git中，当时按照这样的流程添加Git，然后push，提示：push to origin/master war rejected。","text":"push to origin/master was rejected错误解决方案idea中，发布项目到gitee的Git中，当时按照这样的流程添加Git，然后push，提示：push to origin/master war rejected。 解决方案如下：1.切换到自己项目所在的目录，右键选择GIT BASH Here，Idea中可使用Alt+F12 2.在terminl窗口中依次输入命令： 123git pullgit pull origin mastergit pull origin master --allow-unrelated-histories 3.在idea中重新push自己的项目，成功！！！ 原文","categories":[{"name":"笔记","slug":"笔记","permalink":"https://vineo.cn/categories/笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://vineo.cn/tags/Git/"}]}]}